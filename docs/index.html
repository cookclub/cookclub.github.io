<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Ensure the reader fills the safe area on modern mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- Theme color will be updated dynamically based on the active reader theme -->
  <meta id="theme-color-meta" name="theme-color" content="#ffffff" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@600;700&display=swap" rel="stylesheet">
  <title>big spoon society</title>

  <!-- Single-file viewer: no external CSS/JS except epub.js -->
  <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>

  <style>
    :root {
      --bg: #f7f7f8;
      --card: #ffffff;
      --text: #111;
      --muted: #666;
      --brand: #2563eb;
      --brand-2: #1d4ed8;
      --ring: rgba(37, 99, 235, 0.2);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 24px; }
    .nav {
      position: sticky; top: 0; z-index: 10;
      background: var(--card); border-bottom: 1px solid #e5e7eb;
    }
    .nav-inner { max-width: 1100px; margin: 0 auto; padding: 12px 24px; display:flex; align-items:center; justify-content:space-between; }
    .brand { font: 700 20px/1.2 "Fredoka", system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial; text-transform: lowercase; letter-spacing:.2px; }
    .btn {
      appearance: none; border: 1px solid #e5e7eb; background: #fff; color: #111;
      border-radius: 8px; padding: 8px 12px; cursor: pointer;
      /* Mobile hit area */
      min-width: 44px;
      min-height: 44px;
    }
    .btn.brand { background: var(--brand); border-color: var(--brand); color: #fff; }
    .btn.brand:hover { background: var(--brand-2); }
    .grid {
      display: grid; gap: 16px;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
    }
    .card {
      background: var(--card); border: 1px solid #e5e7eb; border-radius: 12px; overflow: hidden;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
      cursor: pointer; transition: transform .06s ease, box-shadow .06s ease;
    }
    .card:hover { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,.06); }
    .cover { aspect-ratio: 16/10; width: 100%; object-fit: cover; display:block; background:#f3f4f6; }
    .card-body { padding: 12px 14px 16px; }
    .title { font-weight: 650; margin: 4px 0 6px; }
    .by { color: var(--muted); font-size: 14px; margin-bottom: 6px; }
    .desc { color: #444; font-size: 14px; display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden; }

    /* Reader layout */
    #reader-view { display: none; height: calc(100vh - 52px); }
    #reader-view.show { display: grid; grid-template-columns: 300px 1fr; }
    /* collapse TOC track when requested (used on phones) */
    body.toc-collapsed #reader-view.show { grid-template-columns: 1fr; }
    body.toc-collapsed #toc { display: none; }
    #toc {
      border-right: 1px solid #e5e7eb; background: #fff; overflow:auto;
    }
    #toc h3 { margin: 14px 16px; font-size: 14px; color: var(--muted); text-transform: uppercase; letter-spacing:.05em; }
    #toc .item { padding: 10px 14px; border-left: 3px solid transparent; cursor: pointer; }
    #toc .item:hover { background: #f8fafc; }
    #toc .item.active { border-left-color: var(--brand); background: #eff6ff; }
    #stage { position: relative; background: #fff; }
    #viewer { width: 100%; height: 100%; }

    .toolbar {
      display:flex; align-items:center; gap:8px; padding: 10px 12px; border-bottom:1px solid #e5e7eb; background:#fff;
    }
    .grow { flex: 1; }
    .range { width: 100%; }
    .loading {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:#fff;
    }
    /* Ensure the loading overlay hides itself when [hidden] is set.  This prevents stuck spinners. */
    #loading[hidden]{display:none!important;}
    .spinner {
      width: 36px; height: 36px; border-radius: 50%; border: 4px solid var(--brand); border-top-color: transparent; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .sr { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    .muted { color: var(--muted); font-size: 14px; }

    /* === Reader sizing and overflow fixes === */
    #reader-view { min-width: 0; min-height: 0; }                 /* grid container */
    #stage       { min-width: 0; min-height: 0; height: 100%; overflow: hidden; }
    #viewer      { min-width: 0; width: 100%; height: 100%; position: relative; }
    #viewer iframe {
      position: absolute; inset: 0;
      width: 100% !important; height: 100% !important;
      display: block; border: 0;
    }

    /* When chrome (toolbar/TOC) is hidden, do not display them */
    body.chrome-hidden .toolbar,
    body.chrome-hidden #toc {
      display: none;
    }

    /* Collapsed TOC for small screens */
    #toc.collapsed {
      display: none;
    }

    /* Safe area handling for iOS and modern browsers */
    @supports(padding: env(safe-area-inset-top)) {
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
      }
    }

    /* Tap zone overlay for navigation and chrome toggling */
    #tap-zones {
      position: absolute;
      inset: 0;
      display: flex;
      z-index: 1;
      pointer-events: none; /* default off */    
    }
    .toolbar { position: relative; z-index: 10; } /* keep toolbar above overlay */
    #tap-zones .tap {
      flex: 1;
      cursor: pointer;
      /* Transparent so underlying text is visible */
      background: rgba(0,0,0,0);
    }
    body.paginated.chrome-hidden #tap-zones { pointer-events: auto; }
  </style>
</head>
<body>

  <!-- Top bar -->
  <div class="nav">
    <div class="nav-inner">
      <div class="brand">EPUB Reader</div>
      <div>
        <button id="to-library" class="btn">Library</button>
      </div>
    </div>
  </div>

  <!-- Library view -->
  <div id="library-view" class="wrap">
    <h1 style="margin: 0 0 12px;">Your Library</h1>
    <p class="muted" style="margin-top:0;">Select a book to start reading.</p>
    <div id="books-grid" class="grid" aria-live="polite"></div>
  </div>

  <!-- Reader view -->
  <div id="reader-view">
    <aside id="toc">
      <h3>Table of contents</h3>
      <div id="toc-items"></div>
    </aside>
    <main id="stage">
      <div class="toolbar">
        <button id="prev" class="btn" title="Previous (←)">◀</button>
        <button id="next" class="btn" title="Next (→)">▶</button>
        <!-- Flow toggle: cycles between paginated and scrolled-doc -->
        <button id="flow-toggle" class="btn" title="Toggle pagination/scroll" aria-label="Toggle pagination or scroll">↕︎</button>
        <!-- Theme toggle: cycles Light → Sepia → Dark -->
        <button id="theme-toggle" class="btn" title="Change theme" aria-label="Cycle reader theme">◑</button>
        <!-- Decrease/increase font size -->
        <button id="font-dec" class="btn" title="Decrease font size" aria-label="Decrease font size">A−</button>
        <button id="font-inc" class="btn" title="Increase font size" aria-label="Increase font size">A+</button>
        <!-- Line-height control: cycles through preset line heights -->
        <button id="line-height-toggle" class="btn" title="Adjust line height" aria-label="Adjust line height">ℓ</button>
        <!-- Toggle TOC on small screens -->
        <button id="toc-toggle" class="btn" title="Toggle table of contents" aria-label="Toggle table of contents">☰</button>
        <div id="chapter" class="muted" style="min-width:140px;"></div>
        <div class="grow"><input id="progress" class="range" type="range" min="0" max="100" value="0" /></div>
        <div id="percent" class="muted" style="min-width:40px; text-align:right;">0%</div>
      </div>
      <div id="viewer" role="region" aria-label="Book content"></div>
      <div id="loading" class="loading" hidden>
        <div>
          <div class="spinner" aria-hidden="true"></div>
          <div class="muted" style="text-align:center; margin-top:10px;">Loading book…</div>
        </div>
      </div>
      <!-- Tap zone overlay for navigation and chrome toggling -->
      <div id="tap-zones" aria-hidden="true">
        <div class="tap" id="tap-left"></div>
        <div class="tap" id="tap-center"></div>
        <div class="tap" id="tap-right"></div>
      </div>
    </main>
  </div>

  <script>
    // User site (cookclub.github.io) -> base "/"
    const BASE = '/';

    const app = {
      books: [],
      book: null,
      rendition: null,
      currentBookId: null,
      currentLocation: null,
      locationsReady: false,

      // Reader preferences (loaded from localStorage). Defaults will be chosen on first run
      prefs: null,

      updateTapZonesState() {
        const isPaginated = document.body.classList.contains('paginated');
        const chromeHidden = document.body.classList.contains('chrome-hidden');
        const tz = document.getElementById('tap-zones');
        if (tz) tz.style.pointerEvents = (isPaginated && chromeHidden) ? 'auto' : 'none';
      },      
      /**
       * Load preferences from localStorage. If none are found, sensible defaults
       * are computed based on viewport width and prefers-color-scheme.
       */
      loadPrefs() {
        const saved = (() => {
          try { return JSON.parse(localStorage.getItem('reader-prefs-v1') || '{}'); } catch (e) { return {}; }
        })();
        const defaults = {};
        // Set flow default based on viewport width: phones scroll, larger screens paginated
        if (!saved.flow) {
          defaults.flow = (window.innerWidth < 768) ? 'scrolled-doc' : 'paginated';
        }
        // Set theme default based on user preference
        if (!saved.theme) {
          defaults.theme = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light';
        }
        // Default font size (percentage) and line height
        if (saved.fontSize == null) defaults.fontSize = 100;
        if (saved.lineHeight == null) defaults.lineHeight = 1.4;
        return Object.assign({ flow: 'paginated', theme: 'light', fontSize: 100, lineHeight: 1.4 }, defaults, saved);
      },

      /** Save current preferences to localStorage */
      savePrefs() {
        try { localStorage.setItem('reader-prefs-v1', JSON.stringify(this.prefs)); } catch (e) {}
      },

      /**
       * Apply user preferences to the active rendition and the page environment.
       * Uses epub.js theme helpers so styles win over book CSS.
       */
      applyPrefs() {
        if (!this.rendition) return;

        const prefs = this.prefs || {};
        const theme      = prefs.theme ?? 'light';
        const fontSize   = prefs.fontSize ?? 100;   // %
        const lineHeight = prefs.lineHeight ?? 1.4; // unitless
        const flow       = prefs.flow ?? 'paginated';

        // --- colors for content (inside iframe) ---
        let bg, text, link;
        if (theme === 'sepia') {
          bg = '#f4ecd8'; text = '#5b4636'; link = '#b16933';
        } else if (theme === 'dark') {
          bg = '#1e1e1e'; text = '#f5f5f5'; link = '#4f8bfa';
        } else {
          bg = '#ffffff'; text = '#111111'; link = '#2563eb';
        }

        // Register a high-specificity theme that beats book CSS
        const css = `
          html, body { background:${bg} !important; color:${text} !important; }
          a, a:link, a:visited { color:${link} !important; }
          p, div, li, blockquote, section, article, span { line-height:${lineHeight} !important; }
          img, svg, figure { max-width:100% !important; height:auto !important; }
        `;
        this.rendition.themes.register('custom', css);
        this.rendition.themes.select('custom');

        // Typography via epub.js helpers (stronger than plain CSS)
        this.rendition.themes.fontSize(`${fontSize}%`);
        this.rendition.themes.override('line-height', `${lineHeight} !important`);

        // Flow / spread
        this.rendition.flow(flow);
        this.rendition.spread(flow === 'paginated' ? 'auto' : false);
        document.body.classList.toggle('paginated', flow === 'paginated');
        this.updateTapZonesState();

        // Keep the outer chrome (header/TOC) in sync with the theme
        const root = document.documentElement.style;
        if (theme === 'sepia') {
          root.setProperty('--bg', '#f4ecd8');
          root.setProperty('--card', '#fbf1d0');
          root.setProperty('--text', '#5b4636');
          root.setProperty('--muted', '#8b715e');
          root.setProperty('--brand', '#c47a3f');
          root.setProperty('--brand-2', '#b16933');
          root.setProperty('--ring', 'rgba(196,122,63,0.2)');
        } else if (theme === 'dark') {
          root.setProperty('--bg', '#1e1e1e');
          root.setProperty('--card', '#2a2a2a');
          root.setProperty('--text', '#f5f5f5');
          root.setProperty('--muted', '#999999');
          root.setProperty('--brand', '#4f8bfa');
          root.setProperty('--brand-2', '#3b76d1');
          root.setProperty('--ring', 'rgba(79,139,250,0.2)');
        } else {
          root.setProperty('--bg', '#f7f7f8');
          root.setProperty('--card', '#ffffff');
          root.setProperty('--text', '#111111');
          root.setProperty('--muted', '#666666');
          root.setProperty('--brand', '#2563eb');
          root.setProperty('--brand-2', '#1d4ed8');
          root.setProperty('--ring', 'rgba(37,99,235,0.2)');
        }

        this.updateThemeColor();
      },
      /**
       * Update the browser theme-color meta tag to reflect the current active theme.
       */
      updateThemeColor() {
        const meta = document.getElementById('theme-color-meta');
        if (!meta || !this.prefs) return;
        let color;
        if (this.prefs.theme === 'sepia') color = '#f4ecd8';
        else if (this.prefs.theme === 'dark') color = '#1e1e1e';
        else color = '#ffffff';
        meta.setAttribute('content', color);
      },

      async boot() {
        // Set up library/reader navigation buttons
        document.getElementById('to-library').addEventListener('click', () => this.routeTo('library'));
        document.getElementById('prev').addEventListener('click', () => this.rendition && this.rendition.prev());
        document.getElementById('next').addEventListener('click', () => this.rendition && this.rendition.next());
        document.getElementById('progress').addEventListener('input', e => this.seek(e.target.value));

        // Initialize user preferences
        this.prefs = this.loadPrefs();

        // Flow toggle button
        document.getElementById('flow-toggle').addEventListener('click', () => {
          this.prefs.flow = (this.prefs.flow === 'paginated') ? 'scrolled-doc' : 'paginated';
          this.savePrefs();
          if (this.rendition) this.applyPrefs();
        });
        // Theme toggle button cycles Light → Sepia → Dark
        document.getElementById('theme-toggle').addEventListener('click', () => {
          const sequence = ['light','sepia','dark'];
          const idx = sequence.indexOf(this.prefs.theme);
          this.prefs.theme = sequence[(idx + 1) % sequence.length];
          this.savePrefs();
          if (this.rendition) this.applyPrefs();
        });
        // Decrease font size
        document.getElementById('font-dec').addEventListener('click', () => {
          this.prefs.fontSize = Math.max(90, (this.prefs.fontSize || 100) - 10);
          this.savePrefs();
          if (this.rendition) this.applyPrefs();
        });
        // Increase font size
        document.getElementById('font-inc').addEventListener('click', () => {
          this.prefs.fontSize = Math.min(150, (this.prefs.fontSize || 100) + 10);
          this.savePrefs();
          if (this.rendition) this.applyPrefs();
        });
        // Line-height toggle cycles through a set of values
        document.getElementById('line-height-toggle').addEventListener('click', () => {
          const steps = [1.2, 1.4, 1.6, 1.8];
          const current = this.prefs.lineHeight || 1.4;
          const idx = steps.indexOf(Number(current));
          this.prefs.lineHeight = steps[(idx + 1) % steps.length];
          this.savePrefs();
          if (this.rendition) this.applyPrefs();
        });
        // Toggle TOC visibility
        document.getElementById('toc-toggle').addEventListener('click', () => {
          document.getElementById('toc').classList.toggle('collapsed');
        });
        // Tap zone controls for prev/next and chrome toggle
        document.getElementById('tap-left').addEventListener('click', (e) => {
          if (this.rendition) this.rendition.prev();
        });
        document.getElementById('tap-right').addEventListener('click', (e) => {
          if (this.rendition) this.rendition.next();
        });
        document.getElementById('tap-center').addEventListener('click', () => {
          document.body.classList.toggle('chrome-hidden');
          this.updateTapZonesState();
        });       
        // When the user selects text (inside or outside iframe) disable tap zone pointer events to allow selection; re-enable otherwise
        const updateTapZones = () => {
          try {
            const sel = document.getSelection();
            const active = sel && sel.toString().trim().length > 0;
            const tz = document.getElementById('tap-zones');
            if (tz) tz.style.pointerEvents = active ? 'none' : 'auto';
          } catch {}
        };
        document.addEventListener('selectionchange', () => setTimeout(updateTapZones, 50));

        window.addEventListener('hashchange', () => this.handleHash());
        await this.loadBooks();
        this.handleHash(); // initial route
      },

      // ---------------------------------------------------
      // Library
      // ---------------------------------------------------
      async loadBooks() {
        try {
          const res = await fetch(`${BASE}books.json`, { cache: 'no-store' });
          this.books = await res.json();
          this.renderLibrary();
        } catch (err) {
          console.error('Failed to load books.json', err);
          document.getElementById('books-grid').innerHTML =
            `<div class="muted">Could not load library.</div>`;
        }
      },

      renderLibrary() {
        const grid = document.getElementById('books-grid');
        grid.innerHTML = '';
        this.books.forEach(b => {
          const card = document.createElement('div');
          card.className = 'card';
          card.innerHTML = `
            <img class="cover" alt="${this.escape(b.title)} cover" src="${b.cover ? b.cover : ''}">
            <div class="card-body">
              <div class="title">${this.escape(b.title)}</div>
              <div class="by">by ${this.escape(b.author || '')}</div>
              <div class="desc">${this.escape(b.description || '')}</div>
            </div>
          `;
          card.addEventListener('click', () => {
            // Use hash routing so GitHub Pages never 404s:
            window.location.hash = `#/read/${encodeURIComponent(b.id)}`;
          });
          grid.appendChild(card);
        });
      },

      // ---------------------------------------------------
      // Reader
      // ---------------------------------------------------
      async openBookById(bookId, locCFI) {
        const meta = this.books.find(b => b.id === bookId);
        if (!meta) {
          console.warn('Unknown book id', bookId);
          return this.routeTo('library');
        }

        this.currentBookId = bookId;
        this.showReader(true);
        this.setLoading(true);

        try {
          // --- Build correct root for epub.js (folder, not OPF) ---
          const src = `${BASE}${meta.href}`;
          const root = src.endsWith('.opf')
            ? ((src.match(/^(.*?\/)OEBPS\//) || [])[1] || src.replace(/[^/]+$/, ''))
            : (src.endsWith('/') ? src : src + '/');

          this.book = ePub(root);

          const viewer = document.getElementById('viewer');
          viewer.innerHTML = '';

          this.rendition = this.book.renderTo(viewer, {
            width: '100%', height: '100%',
            flow: 'paginated',
            allowScriptedContent: true
          });

          await this.book.ready;

          // Apply user preferences (theme, flow, font size, line height) before first render
          try { this.applyPrefs(); } catch (e) { console.warn('applyPrefs failed', e); }

          // Auto-collapse TOC on narrow screens (under 1024px) by switching grid to single column
          if (window.innerWidth < 1024) document.body.classList.add('toc-collapsed');
          else document.body.classList.remove('toc-collapsed');

          // Start location: accept only well-formed CFIs
          const start = (locCFI && /^epubcfi\(.+\)$/.test(locCFI))
            ? locCFI
            : (localStorage.getItem(`lastLocation-${bookId}`) || undefined);

          // Hide spinner on first displayed OR after a short fallback
          const displayedOnce = new Promise(resolve => {
            const handler = () => {
              if (typeof this.rendition.off === 'function') this.rendition.off('displayed', handler);
              resolve();
            };
            this.rendition.on('displayed', handler);
          });
          const timeout = new Promise(res => setTimeout(res, 1200));

          this.rendition.display(start).catch(() => {});
          // Failsafe: remove the loading overlay entirely after 4 seconds in case of stuck spinners
          setTimeout(() => document.getElementById('loading')?.remove(), 4000);
          await Promise.race([displayedOnce, timeout]);
          this.setLoading(false);
          this.updateTapZonesState();

          // Progress + URL sync
          this.rendition.on('relocated', (loc) => {
            this.currentLocation = loc;
            this.updateProgressUI();
            try { localStorage.setItem(`lastLocation-${bookId}`, loc.start.cfi); } catch {}
            const encoded = encodeURIComponent(loc.start.cfi);
            const base = `#/read/${encodeURIComponent(bookId)}`;
            if (!window.location.hash.includes(encoded)) {
              history.replaceState(null, '', `${base}?loc=${encoded}`);
            }
          });

          // TOC
          const nav = await this.book.loaded.navigation;
          this.renderTOC(nav.toc);

          // Locations (background)
          this.locationsReady = false;
          setTimeout(async () => {
            try {
              if (!this.book.locations || this.book.locations.length() === 0) {
                await this.book.locations.generate(800);
              }
              this.locationsReady = true;
              this.updateProgressUI();
            } catch (e) {
              console.warn('locations.generate failed', e);
            }
          }, 0);

        } catch (err) {
          console.error('Error opening book', err);
          this.routeTo('library');
        } finally {
          this.setLoading(false);
        }
      },

      renderTOC(toc) {
        const box = document.getElementById('toc-items');
        box.innerHTML = '';
        toc.forEach(item => {
          const div = document.createElement('div');
          div.className = 'item';
          div.textContent = item.label;
          div.addEventListener('click', () => this.rendition.display(item.href));
          box.appendChild(div);
        });

        // highlight current chapter
        this.rendition.on('relocated', (loc) => {
          const href = loc.start.href && loc.start.href.split('#')[0];
          Array.from(box.children).forEach(el => el.classList.remove('active'));
          // Simple highlight by label substring (nav.hrefs may vary); skip if mismatch
          Array.from(box.children).forEach(el => {
            if (href && el.textContent && href.toLowerCase().includes(el.textContent.toLowerCase().slice(0, 6))) {
              el.classList.add('active');
            }
          });
        });
      },

      seek(percentStr) {
        if (!this.book || !this.book.locations || !this.locationsReady) return;
        const percent = Math.max(0, Math.min(100, Number(percentStr)));
        const cfi = this.book.locations.cfiFromPercentage(percent / 100);
        if (cfi) this.rendition.display(cfi);
      },

      updateProgressUI() {
        const chapter = document.getElementById('chapter');
        const percentEl = document.getElementById('percent');
        const range = document.getElementById('progress');
        if (!this.currentLocation) return;
        const pct = Math.round(this.currentLocation.start.percentage * 100);
        percentEl.textContent = `${pct}%`;
        range.value = String(pct);
        chapter.textContent = this.currentLocation.start.href ? this.currentLocation.start.href.split('/').slice(-1)[0] : '';
      },

      // ---------------------------------------------------
      // Routing
      // ---------------------------------------------------
      handleHash() {
        const hash = (window.location.hash || '').replace(/^#\/?/, '');
        if (!hash) return this.routeTo('library');

        const [route, rest] = hash.split('/');
        if (route === 'read') {
          const [idAndQuery] = [rest || ''];
          const [encodedId, query] = idAndQuery.split('?');
          const id = decodeURIComponent(encodedId || '');
          const params = new URLSearchParams(query || '');
          const loc = params.get('loc') ? decodeURIComponent(params.get('loc')) : null;
          if (id) {
            this.openBookById(id, loc);
          } else {
            this.routeTo('library');
          }
        } else {
          this.routeTo('library');
        }
      },

      routeTo(where) {
        if (where === 'library') {
          this.showReader(false);
          if (window.location.hash && window.location.hash !== '#/library') {
            history.replaceState(null, '', '#/library');
          }
        }
      },

      showReader(show) {
        const lib = document.getElementById('library-view');
        const reader = document.getElementById('reader-view');
        if (show) {
          lib.style.display = 'none';
          reader.classList.add('show');
        } else {
          reader.classList.remove('show');
          lib.style.display = '';
        }
      },

      setLoading(isLoading) {
        const el = document.getElementById('loading');
        if (!el) return;
        el.hidden = !isLoading;
        // Also explicitly toggle inline display so that [hidden] always works
        el.style.display = isLoading ? 'flex' : 'none';
        el.setAttribute('aria-hidden', String(!isLoading));
      },

      escape(s) {
        return String(s || '').replace(/[&<>"']/g, m => ({
          '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
        })[m]);
      }
    };

    // Boot the app
    app.boot();
  </script>
</body>
</html>
